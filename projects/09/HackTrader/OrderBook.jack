/**
 * OrderBook - Limit Order Book with Price-Time Priority Matching
 *
 * Maintains sorted bid (descending) and ask (ascending) price levels,
 * each with associated quantities. Implements a matching engine that
 * executes trades when incoming orders cross the spread.
 *
 * This is the core data structure of any electronic exchange,
 * implemented here in 16-bit integer arithmetic on the Hack platform.
 *
 * Price convention: all prices are fixed-point x10 (e.g., 1055 = 105.5)
 * Maximum levels: 10 per side (configurable via MAX_LEVELS)
 *
 * Copyright 2026 Žarko Gvozdenović (zarko@visaurum.nl). MIT License.
 */
class OrderBook {
    static int MAX_LEVELS;         // Maximum price levels per side
    static int DEFAULT_LAST_PRICE; // Default last price when book is empty (x10)
    static int NO_ASK_SENTINEL;    // Sentinel value when no asks exist (max int)

    field Array bidPrices;   // Bid prices sorted descending (best first)
    field Array bidQtys;     // Quantity at each bid level
    field Array askPrices;   // Ask prices sorted ascending (best first)
    field Array askQtys;     // Quantity at each ask level
    field int bidCount;      // Number of active bid levels
    field int askCount;      // Number of active ask levels
    field int lastPrice;     // Last traded price (x10)
    field int totalVolume;   // Cumulative volume traded
    field int fillPrice;     // Price of most recent fill
    field int fillQty;       // Quantity of most recent fill
    field boolean fillSide;  // Side of most recent fill (true=buy)

    /**
     * Constructs an empty order book.
     * Initializes bid/ask arrays and sets initial state.
     */
    constructor OrderBook new() {
        let MAX_LEVELS = 10;
        let DEFAULT_LAST_PRICE = 1000;
        let NO_ASK_SENTINEL = 32767;

        let bidPrices = Array.new(MAX_LEVELS);
        let bidQtys = Array.new(MAX_LEVELS);
        let askPrices = Array.new(MAX_LEVELS);
        let askQtys = Array.new(MAX_LEVELS);
        let bidCount = 0;
        let askCount = 0;
        let lastPrice = DEFAULT_LAST_PRICE;
        let totalVolume = 0;
        let fillPrice = 0;
        let fillQty = 0;
        let fillSide = false;
        return this;
    }

    /** Disposes all allocated memory. */
    method void dispose() {
        do bidPrices.dispose();
        do bidQtys.dispose();
        do askPrices.dispose();
        do askQtys.dispose();
        do Memory.deAlloc(this);
        return;
    }

    /** Returns the best (highest) bid price, or 0 if no bids. */
    method int getBestBid() {
        if (bidCount = 0) {
            return 0;
        }
        return bidPrices[0];
    }

    /** Returns the best (lowest) ask price, or NO_ASK_SENTINEL if no asks. */
    method int getBestAsk() {
        if (askCount = 0) {
            return NO_ASK_SENTINEL;
        }
        return askPrices[0];
    }

    /** Returns the spread (best ask - best bid) in fixed-point x10. */
    method int getSpread() {
        if ((bidCount = 0) | (askCount = 0)) {
            return 0;
        }
        return askPrices[0] - bidPrices[0];
    }

    /** Returns the mid price ((best bid + best ask) / 2) in x10. */
    method int getMidPrice() {
        if ((bidCount = 0) | (askCount = 0)) {
            return lastPrice;
        }
        return (bidPrices[0] + askPrices[0]) / 2;
    }

    /** Returns the last traded price (x10). */
    method int getLastPrice() {
        return lastPrice;
    }

    /** Returns total volume traded. */
    method int getTotalVolume() {
        return totalVolume;
    }

    /** Returns the most recent fill price. */
    method int getFillPrice() {
        return fillPrice;
    }

    /** Returns the most recent fill quantity. */
    method int getFillQty() {
        return fillQty;
    }

    /** Returns the most recent fill side (true=buy aggressor). */
    method boolean getFillSide() {
        return fillSide;
    }

    /** Returns the number of active bid levels. */
    method int getBidCount() {
        return bidCount;
    }

    /** Returns the number of active ask levels. */
    method int getAskCount() {
        return askCount;
    }

    /** Returns bid price at given level index. */
    method int getBidPrice(int level) {
        if (level < bidCount) {
            return bidPrices[level];
        }
        return 0;
    }

    /** Returns bid quantity at given level index. */
    method int getBidQty(int level) {
        if (level < bidCount) {
            return bidQtys[level];
        }
        return 0;
    }

    /** Returns ask price at given level index. */
    method int getAskPrice(int level) {
        if (level < askCount) {
            return askPrices[level];
        }
        return 0;
    }

    /** Returns ask quantity at given level index. */
    method int getAskQty(int level) {
        if (level < askCount) {
            return askQtys[level];
        }
        return 0;
    }

    /**
     * Adds liquidity at a specific price level.
     * If the price level already exists, adds to its quantity.
     * Otherwise, inserts a new level in sorted position.
     *
     * @param price Price level (x10)
     * @param qty Quantity to add
     * @param isBuy true for bid side, false for ask side
     */
    method void addLiquidity(int price, int qty, boolean isBuy) {
        if (isBuy) {
            do addBidLevel(price, qty);
        } else {
            do addAskLevel(price, qty);
        }
        return;
    }

    /**
     * Submits a market order that crosses the spread.
     * Matches against resting liquidity on the opposite side.
     *
     * @param qty Quantity to fill
     * @param isBuy true = buy (hits asks), false = sell (hits bids)
     * @return The quantity actually filled (may be less if insufficient liquidity)
     */
    method int submitMarketOrder(int qty, boolean isBuy) {
        var int filled;
        var int available;
        var int fillAmount;

        let filled = 0;
        let fillPrice = 0;
        let fillQty = 0;

        if (isBuy) {
            // Buy: sweep ask levels from best (lowest) up
            while ((filled < qty) & (askCount > 0)) {
                let available = askQtys[0];
                if (available > (qty - filled)) {
                    let fillAmount = qty - filled;
                } else {
                    let fillAmount = available;
                }

                let fillPrice = askPrices[0];
                let lastPrice = fillPrice;
                let askQtys[0] = askQtys[0] - fillAmount;
                let filled = filled + fillAmount;

                // Remove level if depleted
                if (askQtys[0] = 0) {
                    do removeAskLevel(0);
                }
            }
        } else {
            // Sell: sweep bid levels from best (highest) down
            while ((filled < qty) & (bidCount > 0)) {
                let available = bidQtys[0];
                if (available > (qty - filled)) {
                    let fillAmount = qty - filled;
                } else {
                    let fillAmount = available;
                }

                let fillPrice = bidPrices[0];
                let lastPrice = fillPrice;
                let bidQtys[0] = bidQtys[0] - fillAmount;
                let filled = filled + fillAmount;

                // Remove level if depleted
                if (bidQtys[0] = 0) {
                    do removeBidLevel(0);
                }
            }
        }

        if (filled > 0) {
            let fillQty = filled;
            let fillSide = isBuy;
            let totalVolume = totalVolume + filled;
        }

        return filled;
    }

    /**
     * Clears the entire order book (both sides).
     * Used when resetting for a new round or difficulty change.
     */
    method void clear() {
        let bidCount = 0;
        let askCount = 0;
        return;
    }

    /**
     * Populates the book with initial liquidity around a mid price.
     * Creates symmetric bid/ask levels with decreasing quantity.
     *
     * @param midPrice The center price (x10)
     * @param tickSize Price increment between levels (x10)
     * @param baseQty Base quantity at best level
     * @param levels Number of levels per side
     */
    method void initializeBook(int midPrice, int tickSize, int baseQty, int levels) {
        var int i;
        var int qty;

        do clear();

        let i = 0;
        while ((i < levels) & (i < MAX_LEVELS)) {
            // Quantity increases away from mid (more liquidity at depth)
            let qty = baseQty + (i * 2);

            // Ask side: midPrice + tickSize, midPrice + 2*tickSize, ...
            do addAskLevel(midPrice + ((i + 1) * tickSize), qty);

            // Bid side: midPrice - tickSize, midPrice - 2*tickSize, ...
            do addBidLevel(midPrice - ((i + 1) * tickSize), qty);

            let i = i + 1;
        }
        return;
    }

    // --- Private helper methods ---

    /**
     * Inserts a bid level in descending price order.
     * If price exists, adds to quantity.
     */
    method void addBidLevel(int price, int qty) {
        var int i;
        var int insertPos;

        // Check if price level already exists
        let i = 0;
        while (i < bidCount) {
            if (bidPrices[i] = price) {
                let bidQtys[i] = bidQtys[i] + qty;
                return;
            }
            let i = i + 1;
        }

        // Find insertion position (descending order)
        if (bidCount = MAX_LEVELS) {
            return;  // Book is full
        }

        let insertPos = 0;
        while ((insertPos < bidCount) & (bidPrices[insertPos] > price)) {
            let insertPos = insertPos + 1;
        }

        // Shift elements right to make room
        let i = bidCount;
        while (i > insertPos) {
            let bidPrices[i] = bidPrices[i - 1];
            let bidQtys[i] = bidQtys[i - 1];
            let i = i - 1;
        }

        // Insert new level
        let bidPrices[insertPos] = price;
        let bidQtys[insertPos] = qty;
        let bidCount = bidCount + 1;
        return;
    }

    /**
     * Inserts an ask level in ascending price order.
     * If price exists, adds to quantity.
     */
    method void addAskLevel(int price, int qty) {
        var int i;
        var int insertPos;

        // Check if price level already exists
        let i = 0;
        while (i < askCount) {
            if (askPrices[i] = price) {
                let askQtys[i] = askQtys[i] + qty;
                return;
            }
            let i = i + 1;
        }

        // Find insertion position (ascending order)
        if (askCount = MAX_LEVELS) {
            return;  // Book is full
        }

        let insertPos = 0;
        while ((insertPos < askCount) & (askPrices[insertPos] < price)) {
            let insertPos = insertPos + 1;
        }

        // Shift elements right
        let i = askCount;
        while (i > insertPos) {
            let askPrices[i] = askPrices[i - 1];
            let askQtys[i] = askQtys[i - 1];
            let i = i - 1;
        }

        // Insert new level
        let askPrices[insertPos] = price;
        let askQtys[insertPos] = qty;
        let askCount = askCount + 1;
        return;
    }

    /** Removes bid level at given index, shifting remaining left. */
    method void removeBidLevel(int index) {
        var int i;
        let i = index;
        while (i < (bidCount - 1)) {
            let bidPrices[i] = bidPrices[i + 1];
            let bidQtys[i] = bidQtys[i + 1];
            let i = i + 1;
        }
        let bidCount = bidCount - 1;
        return;
    }

    /** Removes ask level at given index, shifting remaining left. */
    method void removeAskLevel(int index) {
        var int i;
        let i = index;
        while (i < (askCount - 1)) {
            let askPrices[i] = askPrices[i + 1];
            let askQtys[i] = askQtys[i + 1];
            let i = i + 1;
        }
        let askCount = askCount - 1;
        return;
    }
}
